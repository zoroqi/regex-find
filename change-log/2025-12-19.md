---
version: "0.0.10"
---

# 2025-12-19

## 目標

- [x] 歷史記錄使用單獨視窗進行查看

## 需求

### 歷史記錄使用單獨視窗進行查看

問題: 當前使用的方案是, 在選擇 Regex 輸入框的時候, 通過上下來展示歷史中的正則, 這樣的設計導致閱覽歷史正則很困難.

為了解決在輸入框中通過上下箭頭瀏覽歷史記錄不便的問題, 我們將實現一個獨立的歷史記錄視窗.

**功能設計:**

1.  **觸發方式**:
    *   在應用主界面, 按下 `F3` 鍵可以打開或關閉歷史記錄視窗.
    *   移除原先在正則表達式輸入框中通過 `上/下` 箭頭鍵遍歷歷史記錄的功能.

2.  **視窗界面**:
    *   歷史記錄視窗將作為一個彈出式模態視窗顯示在主界面之上.
    *   視窗內將以表格形式展示歷史記錄, 包含以下列:
        *   `正則表達式` (Regex)
        *   `使用次數` (Count)
        *   `最近使用` (Timestamp)
        *   `首次匹配` (First Match)
    *   表格支持滾動瀏覽所有歷史記錄.
    *   默認按 `最近使用` 時間降序排序 (最新的在最前面).

3.  **交互邏輯**:
    *   在歷史記錄視窗中, 用戶可以使用 `上/下` 箭頭鍵來導航列表.
        * 也可以使用 vim 常見跳轉鍵
    *   當用戶在列表中選中某一行並按下 `Enter` 鍵時:
        *   歷史記錄視窗將關閉.
        *   選中的 `正則表達式` 將被自動填充到主界面的正則表達式輸入框中.
    *   按下 `ESC/F3` 鍵將直接關閉歷史記錄視窗, 不進行任何操作.

4.  **搜索與過濾**:
    *   視窗內將提供一個輸入框, 用戶可以輸入關鍵字來實時過濾歷史記錄.
    *   過濾將作用於 `正則表達式` 和 `首次匹配` 這兩個字段, 以幫助用戶快速找到所需的記錄.

**設計方案:**

1.  **`internal/app/events.go` 與 `internal/app/ui.go`**:
    *   在事件處理邏輯中, 監聽 `F3` 鍵事件, 用於切換 `App` 結構中的狀態標記, 如 `showHistory bool`.
    *   根據 `showHistory` 狀態決定是否渲染歷史記錄視窗.
    *   移除正則輸入框對 `上/下` 箭頭的歷史記錄導航處理.

2.  **`internal/app/history_view.go` (新建)**:
    *   創建一個新的 `tview` 組件 (例如, `HistoryView`) 來實現歷史記錄視窗.
    *   該組件將包含一個 `tview.Table` 用於展示數據和一個 `tview.InputField` 用於搜索.
    *   實現數據填充邏輯, 從 `App.history` 加載數據並渲染到表格中.
    *   實現輸入處理邏輯, 處理 `上/下`, `Enter`, `ESC` 鍵以及搜索框的輸入.
    *   當用戶選擇一個項目時, 定義一個回調函數, 將選定的 `regex` 字符串傳遞回主 `App` 模型.

3.  **`internal/app/app.go`**:
    *   在 `App` 結構體中增加 `showHistory bool` 狀態.
    *   在主模型中處理來自 `HistoryView` 的回調, 更新正則輸入框 (`regexInput`) 的內容.

## 實現過程關鍵點

本次實現的核心是圍繞 `tview` 框架的模態視窗 (Modal) 實現和複合組件 (Composite Primitive) 的事件處理模型, 過程中有幾次重要的重構和修正.

1.  **模態視窗實現的重構**:
    *   **遇到的問題**: 最初嘗試通過 `tview.Pages` 的 `ShowPage`/`HidePage` 機制來顯示歷史視窗, 但這導致了整個主頁面被替換, 而非預期的彈窗效果, 使得 `F3` 看似無效.
    *   **分析與解決**: 意識到這是對 `tview` 頁面管理機制的誤用. 正確的模態視窗應在一個處於最上層的 `tview.Pages` (即 `modalPages`) 上動態添加和移除. 為此, 對UI和事件流進行了較大的重構:
        *   在 `app.go` 的 `App` 結構體中增加了 `keybindingsModal`, `historyPageFlex`, `exportPage` 等字段, 用於持有模態視窗組件的實例.
        *   在 `ui.go` 中, 將這些模態視窗的創建邏輯從 "添加到 `pages`" 改為 "僅創建實例並賦值給 `App` 中的字段".
        *   在 `events.go` 中, 將所有觸發彈窗的事件 (如 `F1`, `F3`) 的處理邏輯從 `pages.ShowPage` 改為 `modalPages.AddPage`, 關閉時則調用 `modalPages.RemovePage`. 這次重構從根本上解決了所有彈窗的顯示問題.

2.  **複合組件的事件處理修正**:
    *   **遇到的問題**: 模態視窗成功顯示後, 歷史記錄頁面 (`HistoryView`) 完全無法響應任何操作 (無法輸入過濾詞, 無法導航列表).
    *   **分析與解決**: 這是 `tview` 中複合組件焦點和事件分派的典型問題. 最初嘗試在 `HistoryView` 這個父容器上設置一個統一的 `InputCapture` 來捕獲所有事件, 但由於焦點實際上已經被 `Focus()` 方法委派給了其內部的 `searchField` (輸入框), 父容器的 `InputCapture` 不會被觸發. 正確的模式是:
        *   移除父容器上統一的 `InputCapture`.
        *   **為每個可交互的子組件分別設置獨立的 `InputCapture`**. 在 `history_view.go` 的 `NewHistoryView` 中, 分別為 `searchField` 和 `table` 設置了它們自己的事件捕獲邏輯.
        *   `searchField` 的捕獲器處理 `Enter`/`向下`鍵 (焦點移到表格) 和 `Esc` (關閉).
        *   `table` 的捕獲器處理 `Enter` (選定), `Esc` (關閉), 和 `向上`鍵 (在頂部時焦點移回搜索框).

3.  **恢復並統一導航鍵**:
    *   **遇到的問題**: 在修復事件處理後, 發現只有手動實現的 `j`/`k` 鍵可以導航, 而 `tview.Table` 默認支持的上下方向鍵失效了.
    *   **分析與解決**: 這個問題同樣源於不正確的事件捕獲. 在為 `table` 實現的 `InputCapture` 中, 如果沒有為某個按鍵定義處理邏輯, 必須將 `event` 原樣返回 (`return event`), 這樣事件才能被傳遞給組件的默認處理器.
        *   通過在 `table` 的 `InputCapture` 中讓 `KeyUp`/`KeyDown` 事件在特定條件不滿足時"穿透"下去, 恢復了方向鍵的默認行為.
        *   同時, 為了統一體驗, 將 `j`/`k` 的處理邏輯修改為生成一個新的 `KeyUp`/`KeyDown` 事件並返回, 從而復用了默認的導航邏輯, 確保了兩種導航方式的行為一致性.

4.  **調整視窗尺寸**:
    *   **問題**: 最初的彈窗尺寸太小, `First Match` 等內容顯示不全.
    *   **解決**: 在 `ui.go` 中, 通過調整包裹 `HistoryView` 的 `tview.Flex` 佈局的 `proportions` 參數 (從 `1:2:1` 和 `1:1:1` 改為 `1:8:1`), 將模態視窗的寬高擴展至約佔螢幕的 80%, 解決了內容可視性問題.

## AI 成本

| Model Usage | Reqs | Input Tokens | Cache Reads | Output Tokens |
| --- | --- | --- | --- | --- |
| gemini-2.5-flash-lite | 11 | 32,737 | 0 | 1,227 |
| gemini-2.5-pro | 71 | 1,258,319 | 4,331,913 | 22,490 |
| gemini-2.5-flash | 47 | 415,109 | 1,771,559 | 48,801 |
