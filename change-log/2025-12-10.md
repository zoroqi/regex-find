---
version: "0.0.3"
---

# 2025-12-10

## 目標

- [ ] 將 Text 輸入框和 Highlighted 框合併成一個

## 需求

### 合併 Text 和 Highlighted 框

問題: 當前在展示匹配結果使用了一個新的 Highlighted 框來展示

需求:
- 將 Text 和 Highlighted 合併成一個輸入框
- 這個輸入框既要保證可以輸入, 也要展示匹配高亮的結果

## 限制

- 在 internal 文件實現所有具體的業務邏輯

## 建議

- 如果需要請寫測試用例

## 實現方案

本次重構的核心是將分離的輸入 (`tview.TextArea`) 與顯示 (`tview.TextView`) 合併為單一的、可交互的 `tview.TextView` 組件. 為克服 `TextView` 不可直接編輯的限制, 我們採用了以下策略:

1.  **自定義編輯器核心 (`internal/editor`):**
    *   創建了一個新的 `editor` 包, 其中包含 `Editor` 結構體, 作為所有文本操作的無狀態後端.
    *   `Editor` 內部使用 `[][]rune` (符文的二維切片) 來存儲文本, 這種結構使得在任意位置進行字符的插入、刪除和換行操作都非常高效.
    *   該結構體負責精確追踪光標的行列位置 (`cursorX`, `cursorY`), 並提供了一系列 API (如 `InsertRune`, `Backspace`, `MoveCursorUp` 等) 來原子化地修改文本內容和光標狀態.

2.  **基於 `SetInputCapture` 的事件驅動編輯:**
    *   我們利用 `tview` 應用的全局 `SetInputCapture` 方法來攔截所有鍵盤事件.
    *   在事件處理器中, 首先檢查當前焦點是否在我們的 `editorView` (`TextView`) 上.
    *   若是, 則根據 `tcell.EventKey` 的類型 (如 `KeyRune` 代表字符, `KeyBackspace` 代表刪除, `KeyUp` 代表方向鍵等), 調用 `editor` 實例對應的處理函數.
    *   每次調用 (例如 `editor.InsertRune()`) 都會更新底層的文本數據或光標位置. 修改完成後, 立即觸發 `updateHighlight` 函數來刷新界面顯示.

3.  **標記式光標渲染 (Marker-based Cursor Rendering):**
    *   為了在充滿 `tview` 顏色標籤的富文本中精確渲染光標, 我們設計了一種健壯且簡單的"標記式"方法, 徹底避免了複雜的索引計算.
    *   **注入標記**: 在 `updateHighlight` 函數中, 我們首先獲取編輯器中的原始純文本. 如果 `editorView` 處於焦點狀態, 我們會在文本的光標位置精確插入一個唯一的、不會引起衝突的字符串標記 (例如 `‹‹CURSOR››`).
    *   **正常高亮**: 接下來, 我們對這個"含有標記的文本"執行常規的正則表達式匹配和高亮處理. 在此過程中, `‹‹CURSOR››` 標記會像普通文本一樣被 `tview.Escape()` 轉義.
    *   **最終替換**: 當所有顏色標籤都插入完畢, 生成最終的富文本字符串後, 我們執行一次簡單的 `strings.Replace`, 將已被轉義的 `‹‹CURSOR››` 標記替換為 `tview` 的反色顯示標籤 (`[::r] [-::]`). 這確保了光標總能準確地出現在它應該在的位置.

4.  **UI 結構簡化:**
    *   主視圖的 `Flex` 佈局被簡化為兩個組件: 頂部的 `regexInput` (`InputField`) 和佔據剩餘空間的 `editorView` (`TextView`).
    *   `cycleFocus` 函數也被更新, 以便焦點只在這兩個組件之間循環切換.

通過以上方案, 我們成功地將編輯功能和高亮顯示功能無縫集成到同一個組件中, 實現了用戶期望的交互體驗.

## 實現過程關鍵點

1.  **核心挑戰**: 在 `tview.TextView` 中實現一個功能完備的編輯器, 最大的困難是在動態生成的高亮標籤中, 如何精確、高效地渲染光標.

2.  **方案演進**:
    *   **初步構想**: 嘗試計算光標在原始文本中的索引, 並將其映射到渲染後的富文本字符串. 此方案因索引在顏色標籤下不斷變動, 導致計算極其複雜且不可靠, 故被放棄.
    *   **最終方案**: 採用 "標記-替換" 策略. 此方案詳見 **[實現方案](#實現方案)** 的第 3 點 "標記式光標渲染". 該方法通過在預處理階段注入臨時標記, 巧妙地繞開了所有複雜的索引計算, 被證實為最簡潔和健壯的解決方案.

## AI 成本

| Model Usage | Reqs | Input Tokens | Output Tokens |
| --- | --- | --- | --- |
| gemini-2.5-flash-lite | 9 | 20,142 | 2,508 |
| gemini-2.5-pro | 25 | 411,450 | 11,902 |
| gemini-2.5-flash | 1 | 23,737 | 182 |
